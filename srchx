#!/usr/bin/perl
#
# (c) 2019 Vitaly Parnas <vp330@parnas.me>
# See LICENSE for licensing information.

use strict;
use warnings;
use 5.010;
use File::Basename;
use Data::Dumper;

# TODO
# shell expansions ('{' '}') don't carry over from the perl context
# ?Recursive tags?

my $DELIM = ';';
my $CONF_FILE = '.' . basename($0) . '.conf';
my $DEBUG = 0;

sub usage ()
{
    say "
Usage: " . basename($0) . " [options] <search terms or tags> <source(s)>
    Options:
      [-h|--help]       - print this message
      [-d|--debug]      - debug mode, default: no,
      [-n|--no-act]     - display search comand, don't execute
      [-c|--count]      - display counts of search results of each file only.
      [-r|--recursive]  - recurse into directories.
";
    exit(1);
}

sub read_ini 
{
    my $ini = shift;
    my $config;
    my $section;
    open(INI, '<', $ini) or die "Could not open file '$ini' $!";
    while (<INI>) {
        chomp;
        next if /^(#|;|\s*$)/; # comments, blanks
        next if s/^\[(.*)\]/$section = $1/sie; # new config section
        /^([^#;]+)\s*=\s*([^#]+)\s*/ and $config->{$section}->{$1} = $2;
    }
    close INI;
    return $config;
}

sub parse_free_args
{
    my ($conf, $params, $searches, $paths) = @_;
    foreach (@$params) {
        my $target;
        my $val = $conf->{"content"}->{$_};
        if ($val) {
            $target = $paths;
        } else {
            $val = ($conf->{"tags"}->{$_} or $_);
            $target = $searches;
        }
        push (@$target, split(/$DELIM/, $val));
    }
    say "Searches: @$searches" if $DEBUG;
    say "Paths @$paths" if $DEBUG;
}

# MAIN
{
    my $conf;
    my (@free_args, @searches, @paths, @grep_options);
    my ($simulate, $count_matches, $recurse, $min_count) = (0,0,0,1);
    my $cmd;

    while ($_ = shift) {
        if (/^(-h|--help)/) { usage(); }
        elsif (/^(-d|--debug)/) { $DEBUG = 1; }
        elsif (/^(-n|--no-act)/) { $simulate = 1; }
        elsif (/^(-c|--count)/) { $count_matches = 1; }
        elsif (/^(-r|--recursive)/) { $recurse = 1;}
        else { push (@free_args, $_); }
    }
    usage() unless (@free_args);
    push (@grep_options, $recurse ? "-r" : "--exclude-dir=/*");
    foreach ("$CONF_FILE", $ENV{HOME} . '/' . $CONF_FILE) {
        if (-e) {
            say "Using conf $_";
            $CONF_FILE = $_;
            last;
        }
    }
    $conf = read_ini($CONF_FILE);
    print Dumper($conf) if $DEBUG;
    parse_free_args($conf, \@free_args, \@searches, \@paths);
    while (my ($filter_name, $val) = each %{$conf->{"filters"}}) {
        if ($filter_name eq "min-count") {
            $min_count = $val;
        } else {
            push (@grep_options, "--$filter_name '$_'")
                foreach split(/$DELIM/, $val);
        }
    }
    $count_matches and unshift (@grep_options, "-cH");
    $cmd = "grep -Ei @grep_options -e '" . join('|', @searches) . "' @paths";
    $count_matches and $cmd .= 
        " | awk -F':' '{if (\$2 >= $min_count) printf(\"%4d : %s\\n\", \$2, \$1)}' | sort -n";
    $cmd .= " | sed 's#$ENV{HOME}#~#'"; # strip verbose $HOME path from results
    say ($simulate ? $cmd : qx($cmd));
    exit(0);
}
